# 二叉树基础及遍历

## 二叉树基础
**二叉树是最重要的基本数据结构，没有之一。**
1. 二叉树是简单的基础数据结构，但是复杂的数据结构都是基于二叉树的
2. 二叉树不单纯是一种数据结构，更是一种常用的算法思维

+ 层级 = 高度 = h

+ 满二叉树（Perfect Binary Tree）
  + 正三角形，每一层节点都是满的
  + 总节点个数 = 2^h - 1
+ 完全二叉树（Complete Binary Tree）
  1. 每一层的节点都紧凑靠左排列 
  2. 除了最后一层，其他每层都必须是满的
+ Full Binary Tree
  + 所有节点要么没有孩子节点，要么有两个孩子节点。
+ 二叉搜索树（Binary Search Tree，BST）
  + 每个节点都符合「左小右大」
  + BST的优势 可以在BST中快速找到某个节点，或者找到某个范围内的所有节点
+ 高度平衡二叉树（Height-Balanced Binary Tree）
  + 「每个节点」的左右子树的高度差不超过 1。
  + 假设共有N个节点，那么高度平衡二叉树的高度是 O(log⁡N)，增删查改效率会很高
+ 自平衡二叉树（Self-Balanced Binary Tree）
  + 红黑树，是一种自平衡的二叉搜索树

### 二叉树的实现方式
+ 链表（常用） 数组 递归树 哈希表（邻接表？）

## 二叉树的递归/层序遍历
**二叉树只有递归遍历和层序遍历这两种，再无其他**
+ 递归遍历的节点顺序是固定的，但是有三个关键位置，在不同位置插入代码，会产生不同的效果。
+ 层序遍历的节点顺序也是固定的，但是有三种不同的写法，对应不同的场景。
+ 递归和层序在时间复杂度上是同一量级。

### 递归(堆栈) → DFS
+ 递归遍历的顺序仅取决于左右子节点的递归调用顺序，与其他代码无关
+ 默认为先左后右，每个父节点都会访问三次（第一次，左子树，右子树）
+ 前序(preorder)  中序(inorder) 后序(postorder)：根据当前的位置，节点的信息量的不同
  ``` python
  # 二叉树的遍历框架
  def traverse(root):
      if root is None:
          return
      # 前序位置 仅知道父节点
      traverse(root.left)
      # 中序位置 父节点，左子树
      traverse(root.right)
      # 后序位置 （信息量最全）父节点，左子树，右子树
  ```
+ 二叉搜索树的中序遍历结果有序，这是BST的一个重要性质。
> 【TODO】Leecode：144. 二叉树的前序遍历、94. 二叉树的中序遍历、145. 二叉树的后序遍历

### 层序(队列) → BFS
+ (简单)无深度
  + 队列实现，每次把队头元素拿出来，然后把它的左右子节点加入队列
+ (常用)记深度
  + 除列表外，还有一个额外的参数来记录层数
  + 由于循环过程中队列的长度是会变化的，队列的长度一定要在循环开始前保存下来，不能直接用 q.size() 作为循环条件
+ (灵活)复杂场景
  + 添加一个 State 类，每个节点维护自己的路径权重和

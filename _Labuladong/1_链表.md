# 链表
## 双指针技巧秒杀七道链表题目
1. 合并两个有序链表
   + [Leecode] 21. Merge Two Sorted Lists
   + 双指针，分别对比两个链表的value  
   + 虚拟头结点dummy，当需要创造新链表的时候，可以使用虚拟头结点简化边界情况的处理。

2. 链表的分解
   + [Leecode] 86. Partition List
   + 三指针，将原链表分解为两个链表再合并
   + 在原链表中移动时需要进行断链，避免在子链中带入原来的链表关系

3. 合并 k 个有序链表
   + [Leecode] 23. Merge k Sorted Lists
   + 解法1 多指针，利用优先级队列（二叉堆）来排序 → [优先级队列代码实现](数据结构/优先级队列代码实现.md)
   + 利用元组来pack需要的对比信息，包括（结点val，第k个链表，结点ref）
   + 时间复杂度，k个链表push O(logk) + pop O(logk), *N个结点 = O(Nlogk)
   + 解法2 分治算法
  
4. 寻找单链表的倒数第 k 个节点
   + 解法1 先遍历获取链表总数n，再遍历到n-k
   + 解法2 双指针，第一个指针先走k步，再同步遍历到end
   + [Leecode] 19. Remove Nth Node From End of List
   + 删除目标节点前，先定位到目标的前驱节点
   + 虚拟头结点dummy简化边界条件

5. 寻找单链表的中点
   + [Leecode] 876. Middle of the Linked List
   + 解法1 先遍历获取链表总数n，n/2
   + 解法2 双指针，快指针每次走2步，到end的时候，慢指针的位置就是中点
   + 双中点时，标准p2=head → 后中点，p2=head.next → 前中点
   + 可拓展为判断成环

6. 判断单链表是否包含环并找出环起点
   + [Leecode] 141. Linked List Cycle
   + [Leecode] 142. Linked List Cycle II
   + 解法1 哈希表记录，额外的空间复杂度
   + 解法2 双指针，如果快慢指针相遇就是有环，相遇之后再次重置一个指针正常前进，再相遇的位置即为起点

7. 判断两个单链表是否相交并找出交点
   + [Leecode] 160. Intersection of Two Linked Lists
   + 关键在于让两个指针同时到达相交点
   + 解法1 哈希表记录，额外的空间复杂度
   + 解法2 将B接在A之后，A接在B之后，然后同步走，若相遇即相交
   + 解法3 A和B相连查看是否成环并输出环起点，但是需要还原
   + 解法4 先让长的那个走A和B的差值步数，再同步走

## 【练习】链表双指针经典习题
### 链表的分解
+ [Leecode] 82. Remove Duplicates from Sorted List II
  + 解法1 哈希集合记录重复结点
  + **解法2** 链表分解，分为重复链和不重复链
  + 注意重复和不重复情况的设计
  + 解法3 双指针直接连同自己删除
   + → [Leecode] 83. Remove Duplicates from Sorted List
   + 单指针直接删除
  + 解法4 递归

### 链表的合并
+ [Leecode] 378. Kth Smallest Element in a Sorted Matrix
  + 解法 优先级队列合并K个链表
  + 先循环弹出k-1个，然后再直接return第k个

+ [Leecode] 373. Find K Pairs with Smallest Sums
  + 解法 思路同上
  + 将num1每个元素的配对算做一条链

### 链表运算题
+ [Leecode] 2. Add Two Numbers
  + 解法 对应位数相加，并用额外的carry存储是否进位

+ [Leecode] 445. Add Two Numbers II
  + 解法 倒序存储，反转链表或者使用栈来辅助
  + **反转链表**类似于不断头插，最终返回的是最后一个节点自身而不是Null
  + 反转链表会改变输入自身

## 如何判断回文链表
+ [Leecode] 234. Palindrome Linked List
+ 数组回文串的判断方法，从两端向中间逼近
+ 回文串的对称属性是解决关键，正着读和反着读都一样
### 判断回文单链表
+ 类似树结构，链表结构可以有前序和后序等思路，不需要显式反转也可以倒序链表
```python
# 递归遍历单链表
def traverse(head: ListNode) -> None:
    # 前序遍历代码
    traverse(head.next)
    # 后序遍历代码
```
+ 解法1 
  + 双指针：left从head，right利用后序遍历，同步对比left和right的值是否为回文
  + 但是遍历的本质就是调用栈，所以时间复杂度为On，空间复杂度也为On

### 优化空间复杂度
+ [Leecode] 234. Palindrome Linked List
+ 解法2
  + 反转后半段链表，空间复杂度降为O1
  + 注意链表分为奇偶
  + 反转链表会改变链表自身，需要进行额外的处理反转回来 -> 直接将反转的头结点再进行反转

## 反转链表
### 反转整个单链表
+ [Leecode] 206. Reverse Linked List
+ 解法1 迭代法 三指针反转链表
   > 出现类似 nxt.next时，就要想到先判断 nxt 是否为 null，否则容易出现空指针异常
+ 解法2 递归法 
+ 递归法的关键在于，该问题可以存在子问题
   > 「分解问题」的思路，通过递归函数的定义，把原问题分解成若干规模更小、结构相同的子问题，最后通过子问题的答案组装原问题的解
```python
class Solution:
    def reverseList(self, head):
        if head is None or head.next is None:
            return head
         # 可以抽象为Head->ReverseList(B<-C<-D)
        last = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return last
```
||迭代法|递归法|
|---|---|---|
|时间复杂度|O(N)|O(N)|
|空间复杂度|O(1)|O(N)调用栈|
|特点|效率高|练习递归思维|

### 反转前N个结点
+ 迭代解法
  + 利用N的计数进行控制
  + 将反转之后的结尾续借到之后的结点上 head.next = cur
+ 递归解法
  + 利用递归N-1来进行控制

### 反转链表的一部分
+ [Leecode] 92. Reverse Linked List II
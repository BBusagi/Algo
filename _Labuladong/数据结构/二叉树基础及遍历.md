# 二叉树基础及遍历
## 二叉树基础及常见类型
**二叉树是最重要的基本数据结构，没有之一。**
1. 二叉树是简单的基础数据结构，但是复杂的数据结构都是基于二叉树的
2. 二叉树不单纯是一种数据结构，更是一种常用的算法思维

+ 层级 = 高度 = h

+ 满二叉树（Perfect Binary Tree）
  + 正三角形，每一层节点都是满的
  + 总节点个数 = 2^h - 1
+ 完全二叉树（Complete Binary Tree）
  1. 每一层的节点都紧凑靠左排列 
  2. 除了最后一层，其他每层都必须是满的
+ Full Binary Tree
  + 所有节点要么没有孩子节点，要么有两个孩子节点。
+ 二叉搜索树（Binary Search Tree，BST）
  + 每个节点都符合「左小右大」
  + BST的优势 可以在BST中快速找到某个节点，或者找到某个范围内的所有节点
+ 高度平衡二叉树（Height-Balanced Binary Tree）
  + 「每个节点」的左右子树的高度差不超过 1。
  + 假设共有N个节点，那么高度平衡二叉树的高度是 O(log⁡N)，增删查改效率会很高
+ 自平衡二叉树（Self-Balanced Binary Tree）
  + 红黑树，是一种自平衡的二叉搜索树

### 二叉树的实现方式
+ 链表（常用） 数组 递归树 哈希表（邻接表？）

## 二叉树的递归/层序遍历
**二叉树只有递归遍历和层序遍历这两种，再无其他**
+ 递归遍历的节点顺序是固定的，但是有三个关键位置，在不同位置插入代码，会产生不同的效果。
+ 层序遍历的节点顺序也是固定的，但是有三种不同的写法，对应不同的场景。
+ 递归和层序在时间复杂度上是同一量级。

### 递归(堆栈) → DFS Depth-First Search
+ 递归遍历的顺序仅取决于左右子节点的递归调用顺序，与其他代码无关
+ 默认为先左后右，每个父节点都会访问三次（第一次，左子树，右子树）
+ 前序(preorder)  中序(inorder) 后序(postorder)：根据当前的位置，节点的信息量的不同
  ``` python
  # 二叉树的遍历框架
  def traverse(root):
      if root is None:
          return
      # 前序位置 仅知道父节点
      traverse(root.left)
      # 中序位置 父节点，左子树
      traverse(root.right)
      # 后序位置 （信息量最全）父节点，左子树，右子树
  ```
+ 二叉搜索树的中序遍历结果有序，这是BST的一个重要性质。
> 【TODO】Leecode：144. 二叉树的前序遍历、94. 二叉树的中序遍历、145. 二叉树的后序遍历

### 层序(队列) → BFS Breadth-First Search
+ (简单)无深度
  + 队列实现，每次把队头元素拿出来，然后把它的左右子节点加入队列
+ (常用)记深度
  + 除列表外，还有一个额外的参数来记录层数
  + 由于循环过程中队列的长度是会变化的，队列的长度一定要在循环开始前保存下来，不能直接用 len(q) 作为循环条件
+ (灵活)复杂场景
  + 添加一个 State 类，每个节点维护自己的路径权重和

## 🔒多叉树的递归/层序遍历
**多叉树的结构和遍历均是二叉树的延伸**
`self.children = []`
```python
class Node:
    def __init__(self, val: int):
        self.val = val
        self.children = []
```
### 森林（forest）
+ 森林就是多个多叉树的集合（单独一棵多叉树也是一个特殊的森林）
`List<Node> forest;`

### DFS
+ N叉树的遍历由于没有左右之分，所有没有中序遍历
```
# N 叉树的遍历框架
def traverse_n_ary_tree(root):
    if root is None:
        return
    # 前序位置
    for child in root.children:
        traverse_n_ary_tree(child)
    # 后序位置
```
### BFS
``` 方法1 简单
...
q = deque()
q.append(root)
while q:
  cur = q.popleft()
  print(cur)
  for child in cur.childres:
    q.append(child)
```
``` 方法2 层级记录
...
q = deque()
p.append(root)
depth = 1
while q:
  sz = len(q)
  for i in range(sz):
    cur = p.popleft()
    print("{depth} {cur}")
    for child in cur.children
      q.append(child)
  
  depth += 1
```
``` 方法3 带权
class State:
  def __init__(self, node, depth):
    self.node = node
    self.depth = depth
...
q = deque()
q.append(State(root, 1))
while q:

```

## 🔒DFS 和 BFS 的适用场景
### BFS查找最短路径
+ [例] LeeCode 111
  + 二叉树的最小深度即是求最短距离
  + dfs需要遍历所有的子树才能确定结果
  + bfs第一次遇到目标节点时，所经过的路径就是最短路径，可以提前结束
### DFS穷举所有路径
+ 若使用bfs来查找所有路径需要使用第三种复杂写法，假如state类维护当前节点路径
+ dfs写法简单，天然适合
  
## 二叉搜索树的应用及可视化
二叉搜索树 BST 左小右大
+ 二叉搜索树是特殊的二叉树结构，主要应用为TreeMap和TreeSet
+ 树结构需要较强的递归思维
### 二叉搜索树的优势
+ BST可以快速找到某个节点，或者某个范围内的所有节点
+ BST vs 普通二叉树
  + BST理想时间复杂度 O(logn)
  + 普通二叉树时间复杂度 O(n)

### 🔒 TreeMap/TreeSet 实现原理
+ 和HashMap将键值对存在Table中类似，TreeMap将键值对存再二叉搜索树中
+ 而TreeSet就是TreeMap的简单封装
+ TreeMap 主要接口功能和其复杂度
  + Map 键值映射的基本方法
    + 增/改，O(logN)
    + 查，O(logN)
    + 删，O(logN)
    + 是否包含键key，O(logN)
    + 返回所有键的集合，结果有序，O(N)
  + TreeMap 提供的额外方法
    + 查找最小键，O(logN)
    + 查找最大键，O(logN)
    + 查找小于等于key的最大键，O(logN)
    + 查找大于等于key的最小键，O(logN)
    + 查找排名为k的键，O(logN)
    + 查找键key的排名，O(logN)
    + 区间查找，O(logN + M)，M 为区间大小

### 实现原理的简单介绍
+ get：根据目标key和当前节点的key比较，决定往左走还是往右走，可以直接排除一半的节点
+ put, remove, containsKey：先利用get再做操作
+ floorKey, ceilingKey：和get类似
+ rangeKeys： 对比左右子树和临界值
+ firstKey, lastKey：一直向左查找非空节点；一直向右查找非空节点
+ keys：**BST的中序有序**性质

### selectKey, rank
+ 可以利用中序有序进行k次遍历 O(k)
+ 在节点中添加size字段，记录子树的节点总数，将复杂度降到Ologn
+ 通过左子节点的个数+1来判断向左还是向右查找

### 性能
+ 当BST不平衡的时候，复杂度会退化到On
+ **二叉搜索树的性能取决于树的高度，树的高度取决于树的平衡性**
+ 红黑树是一种自平衡的二叉搜索树
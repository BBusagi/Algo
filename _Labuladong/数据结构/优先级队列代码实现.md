# 二叉堆/优先级队列代码实现

## 简化版优先级队列
+ 不考虑泛型，只保存整数
+ 不考虑扩容问题
+ 底层只考虑小顶堆（根节点是最小值），不支持自定义比较器
+ API
    + size, push, peek, pop
+ 难点：插入和删除的元素的时候，还需要保持堆的性质

### 增：push/swim 方法插入元素
1. 新元素添加到底层，保持二叉树
2. 不断swim，直到父节点比其小，或者根节点
### 删：pop/sink 方法删除元素
1. 删除堆顶元素，将底层结点移动到堆顶
2. 不断sink，直到子节点比其大或到达叶子节点
### 查：peek 方法查看堆顶元素
+ 直接返回根节点的值

### 在数组上模拟二叉树
+ **二叉堆之所以是二叉堆，不是因为它像一棵树，而是因为它被设计成“可以用数组直接表示的一棵树”。**
+ 前提是完全二叉树,保持堆序性质
``` python
# 从1开始存储
# 父节点的索引
def parent(node: int) -> int:
    return (node - 1) // 2

# 左子节点的索引
def left(node: int) -> int:
    return node * 2 + 1

# 右子节点的索引
def right(node: int) -> int:
    return node * 2 + 2
```
+ 代码实现和调用 → [优先级队列](../../不同语言的语义映射表.md#优先级队列)
# 图结构
## 图结构的通用代码实现
+ 图就是多叉树的延伸，由Vertex和Edge组成；并且在图中可以在节点之间相互指向
  + 逻辑结构 - 类似于多叉树节点
  + 具体实现 - 邻接表、邻接矩阵
+ 经典算法，二分图，拓扑，最短路径，最小生成树
### 邻接表和邻接矩阵实现图结构
+ 邻接表的空间复杂度是O(V+E)，而邻接矩阵的空间复杂度是O(V^2)
+ 一般算法题中主要使用邻接表，邻接矩阵的优势在于矩阵的数学特性

### 不同种类的图结构
+ **更复杂的图模型都是基于最简单的图衍生出来的。**
  + 有向加权图 
    + 邻接表 - Edge中存储节点和权重
    + 邻接矩阵 - int记录权重，0表示不相邻
  + 无向图 - 无向图等于双向图

### 图结构的通用代码实现
+ 基本的实现API
  + addEdge
  + removeEdge
  + hasEdge
  + weight
  + neighbors
  + size
+ 拓展图
  + 有向加权图（邻接表实现）
  + 有向加权图（邻接矩阵实现）
  + 有向无权图（邻接表/邻接矩阵实现）
  + 无向加权图（邻接表/邻接矩阵实现）
  + 无向无权图（邻接表/邻接矩阵实现）

## 图结构的 DFS/BFS 遍历
+ 图的遍历就是多叉树的遍历，但是在图中存在循环，需要进行标记避免死循环
+ 具体可分为***节点** **边** **路径** 三种场景
  + 节点定义是什么，系统中有什么东西
  + 边定义能不能，两个节点之间是否有关系
  + 路径定义怎么走，从节点到另一个节点经历了什么

### 深度优先搜索（DFS）
#### 遍历所有节点（visited数组）
+ 遍历过程中使用visited数组 避免死循环
+ 时间复杂度 O(Edge+Vertex)，边的总数+节点的总数
> 为什么需要加上Edge而不是直接O(V)?
> 因为在二叉树/多叉树中也应该算上边，只是由于近似相等所以O(N+N)=O(N)
> 而在图中节点和边的关系不明确，只能是O(E+V)

#### 遍历所有边（二维visited数组）
+ 不常用 主要在**计算欧拉路径**使用
+ 利用二维数组来记录遍历过的边
+ 非高效 时间复杂度O(E+V^2)，空间复杂度O(V^2)

#### 遍历所有路径（onPath 数组）
+ 由于在图结构中path可能不止一条，需要在前序中进行标记，在后序中撤销标记
> 为什么在遍历节点的时候就不需要撤销标记
> 因为标记的作用是标准每个节点只会访问一次，全部访问完毕后即返回
> 但是在遍历路径的时候存在多次访问

#### 同时使用 visited 和 onPath 数组
+ 由于遍历路径的复杂度较高，可以在遍历过程中使用visited进行剪枝

#### 完全不用 visited 和 onPath 数组
+ 当题目中明确指出不成环(DAG)

### 广度优先搜索（BFS）
+ 也是需要visited来避免重复
+ **BFS一般用来寻找最短路径，不会用来求所有路径**
+ 最短路径为遍历节点

#### 写法一 不记录遍历步数

#### 写法二 记录遍历步数
+ 通过在while中记录len长度来计算层级

#### 写法三 适配不同权重边
+ 该写法稍作修改就能得到Dijkstra，完成加权图的最短路径计算